// COMPILED ON LINUX: g++ lab2.cpp -o lab2 -fopenmp $(pkg-config opencv --cflags --libs)#include <iostream>#include <math.h>#include <opencv2/opencv.hpp>#include <omp.h>#include <unistd.h> // sleepusing namespace cv;using namespace std;#define PI 3.14159265359int main(int argc, char** argv ){    int start_time = omp_get_wtime();        if (argc != 2 ) {        cout << "usage: <Image_Path>" << endl;        return -1;    }    Mat image = imread(argv[1], 1);    if (!image.data) {        cout << "No image data" << endl;        return -1;    }    cout << "\nNº of processors available = " << omp_get_num_procs ( ) << endl;    cout << "Nº of threads = " << omp_get_max_threads ( ) << endl;    cout << "\nOriginal image: " << (int)image.rows << " x " << (int)image.cols << endl;    omp_set_num_threads(omp_get_max_threads());    Vec3b intensity;    int nRows=image.rows, nCols=image.cols;    int r,c;    uchar red, green, blue;        Mat image_gray(Size(nCols,nRows), CV_8UC1);    #pragma omp parallel for private(r,c,intensity,blue,red,green) shared(image)    for (r = 0; r < nRows; r++)        for (c = 0; c < image.cols; c++) {            intensity = image.at<Vec3b>(r, c);            blue  = intensity.val[0];            green = intensity.val[1];            red   = intensity.val[2];            image_gray.at<uchar>(r, c) = (int)((blue + green + red) / 3);        }    /*    int maxi=(int)image_gray.at<uchar>(0,0);        #pragma omp parallel for private(r,c) shared(maxi)    for (r = 0; r < nRows; r++)        for (c = 0; c < nCols; c++) {            if((int)image_gray.at<uchar>(r,c)>maxi)                maxi=(int)image_gray.at<uchar>(r,c);        }    cout << "MAXi=" << maxi << endl;    */    int r_out,c_out;    double real=0, imag=0;    double dft_mag[nRows][nCols];    double dft_pha[nRows][nCols];        //int i=1;    //Mat image_mag1(Size(nCols,nRows), CV_8UC1);    //Mat image_pha1(Size(nCols,nRows), CV_8UC1);    //omp_set_num_threads(1);    #pragma omp parallel for private(r_out,c_out,r,c,real,imag) shared(image_gray,dft_mag,dft_pha)    // output data    for (r_out = 0; r_out < nRows; r_out++)        for (c_out = 0; c_out < nCols; c_out++) {            // input data            real=0; imag=0;             for (r = 0; r < nRows; r++)                for (c = 0; c < nCols; c++) {                    real += (int)image_gray.at<uchar>(r,c) * cos(2*PI*((double)r*r_out/nRows + (double)c*c_out/nCols));                    imag += (int)image_gray.at<uchar>(r,c) * (-1)*sin(2*PI*((double)r*r_out/nRows + (double)c*c_out/nCols));                    //cout << "arg=" << (double)r*r_out/nRows + (double)c*c_out/nCols << " , " << (double)2*PI*((double)r*r_out/nRows + (double)c*c_out/nCols) << " cos=" << cos(2*PI*((double)r*r_out/nRows + (double)c*c_out/nCols)) << endl;                     //cout << "gray=" << (int)image_gray.at<uchar>(r,c) << " cos()=" << cos(2*PI*(r*r_out/nRows + c*c_out/nCols)) << " Total=" << (int)image_gray.at<uchar>(r,c) * cos(2*PI*(r*r_out/nRows + c*c_out/nCols)) << endl;                     //cout << " Position(k,l)|(r,c): " << r_out << ", " << c_out << " | " << r << ", " << c << endl;                    //cout << "real(in)=" << real << endl;                 }             //cout << "real(out)=" << real << endl;             //sleep(1);                #pragma omp critical            {            //cout << "P(k,l)= " << r_out << ", " << c_out << " - Nº " << i++ << endl;             double magnitude=sqrt(pow(real,2) + pow(imag,2));             double phase=atan(imag/real);         // 1 radian is equivalent to 180/PI degrees            dft_mag[r_out][c_out] = magnitude;            dft_pha[r_out][c_out] = phase;            //image_mag1.at<uchar>(r_out,c_out) = log(1+magnitude);            //image_pha1.at<uchar>(r_out,c_out) = abs(phase*100);            //cout << "z= " << real << " + j" << imag << " - |z|=" << magnitude << " º=" << phase << endl;            //cout << "MAG=" << (int)image_mag.at<uchar>(r_out,c_out) << " PHA=" << (int)image_pha.at<uchar>(r_out,c_out) << endl;            //sleep(1);              }            }            double max=dft_mag[0][0];      #pragma omp parallel for private(r,c)    for (r = 0; r < nRows; r++)        for (c = 0; c < nCols; c++) {            if(dft_mag[r][c]>max)                #pragma omp critical                max=dft_mag[r][c];        }    //cout << "\nMAX=" << max << endl;        Mat image_mag(Size(nCols,nRows), CV_8UC1);    #pragma omp parallel for private(r,c) shared(image_mag)    for (r = 0; r < nRows; r++)        for (c = 0; c < nCols; c++) {            image_mag.at<uchar>(r, c) = (dft_mag[r][c]*255)/max;        }    max=dft_pha[0][0];      #pragma omp parallel for private(r,c)    for (r = 0; r < nRows; r++)        for (c = 0; c < nCols; c++) {            if(dft_pha[r][c]>max)                #pragma omp critical                max=dft_pha[r][c];        }    //cout << "\nMAX=" << max << endl;       Mat image_pha(Size(nCols,nRows), CV_8UC1);    #pragma omp parallel for private(r,c) shared(image_pha)    for (r = 0; r < nRows; r++)        for (c = 0; c < nCols; c++) {            image_pha.at<uchar>(r, c) = abs((dft_pha[r][c]*255)/max);        }//  *********   OUTPUT  *********        int runtime = omp_get_wtime() - start_time;    cout << "\nTime = " << runtime << " seconds = " << runtime/60 << " minutes\n" << endl;    imshow("Grayscale Image", image_gray);    imwrite("image_grayscale.jpg", image_gray);    imshow("Magnitude DFT", image_mag);    imwrite("image_dft_mag.jpg", image_mag);    imshow("Phase DFT", image_pha);    imwrite("image_dft_pha.jpg", image_pha);    //imshow("Mag. DFT (log)", image_mag1);    //imwrite("image_dft_mag.jpg", image_mag1);    //imshow("Phase DFT (log)", image_pha1);    //imwrite("image_dft_pha.jpg", image_pha1);    waitKey(0);    return 0;}